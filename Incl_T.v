(************************************************************************)
(* Copyright 2006 Milad Niqui                                           *)
(* This file is distributed under the terms of the                      *)
(* GNU Lesser General Public License Version 2.1                        *)
(* A copy of the license can be found at                                *)
(*                  <http://www.gnu.org/licenses>                       *)
(************************************************************************)

Require Import digits.
Require Import Bounded_M.
Require Import Bounded_T.
Require Import Incl_M.
Require Import Raxioms.
Require Import RIneq.
From QArithSternBrocot Require Import R_addenda.
Require Import Fourier_solvable_ineqs.

Open Scope Q_scope.

(** Properties of the emission condition for tensors. *)

(** Note: in this file classical properties of reals are used.
However, this use is #<em>#not#</em># inevitable, rather practical. *)


Lemma Incl_T_L_unfolded:forall xi r1 r2,(-1<=r1<=1)%R->(-1<=r2<=1)%R->Incl_T xi LL -> (-1<=as_Tensor xi r1 r2<=0)%R.
Proof.
 intros (((a,b),(c,d)),((e,f),(g,h))) r1 r2 H_r1 H_r2; unfold as_Tensor, Incl_T, map_digits, fst, snd;
 replace 3%Z with (2+1)%Z; trivial; rewrite (Z_to_Qplus 2 1);
 intros [H_vanish [H1 [H2 [H3 [H4 [H5 [H6 [H7 H8]]]]]]]];
 generalize (Bounded_T_e_mf_mg_h_nonzero _ _ _ _ _ _ _ _ H_vanish); 
 generalize (Bounded_T_me_mf_g_h_nonzero _ _ _ _ _ _ _ _ H_vanish); 
 generalize (Bounded_T_me_f_mg_h_nonzero _ _ _ _ _ _ _ _ H_vanish); 
 generalize (Bounded_T_e_f_g_h_nonzero _ _ _ _ _ _ _ _ H_vanish); intros H_efgh4 H_efgh3 H_efgh2 H_efgh1;
 generalize (Bounded_T_M_1 _ _ _ _ _ _ _ _ H_vanish);
 generalize (Bounded_T_M_2 _ _ _ _ _ _ _ _ H_vanish); intros H_vanish2 H_vanish1.

 destruct (Rle_dec_weak 0 ((a*r2+b)*(g*r2+h)-(c*r2+d)*(e*r2+f))) as [H_det2|H_det2];
 split.
  (* 0<=Det2, SPLIT 1 (1/4 OF TOTAL) *)
  (* q is increasing with r2 fixed, so we prove -1<=q(-1,r2)<= q(r1,r2) *)
  apply Rle_trans with (((Qminus c a)*r2+(Qminus d b))/((Qminus g e)*r2+(Qminus h f)))%R.

   destruct (Qle_dec_weak 0 ((c-a)*(h-f)-(d-b)*(g-e))) as [H_det|H_det].
    (* q(-1,-1)<=q(-1,r2) *)
    apply Rle_trans with (((a-c)+(d-b))/((e-g)+(h-f)))%R.
     rationalify_R; apply Incl_M_L_unfolded_auxiliary_7; trivial.
       ring_exact_Q H_efgh1.
       ring_exact_Q H1...
      stepl (((Qminus c a)*(-1)+(Qminus d b))/((Qminus g e)*(-1)+(Qminus h f)))%R.
      apply (det_nonneg_nondecreasing (c-a) (d-b) (g-e) (h-f) (-1)%R r2 H_vanish1 H_det min_one_is_in_base_interval H_r2 (proj1 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
    (* q(-1,1)<=q(-1,r2) *)
    apply Rle_trans with (((c-a)+(d-b))/((g-e)+(h-f)))%R.
     rationalify_R; apply Incl_M_L_unfolded_auxiliary_7; trivial. 
       ring_exact_Q H_efgh2.
       ring_exact_Q H3...
     stepl (((Qminus c a)*1+(Qminus d b))/((Qminus g e)*1+(Qminus h f)))%R.
      apply (det_nonpos_nonincreasing (c-a) (d-b) (g-e) (h-f) r2 (1)%R H_vanish1 H_det H_r2 one_is_in_base_interval (proj2 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
   (* This is the subgoal generated by Rle trans. Back to: q(-1,r2)<=q(r1,r2) *)
   stepl ((a*(-1)*r2+b*(-1)+c*r2+d)/(e*(-1)*r2+f*(-1)+g*r2+h))%R.
    apply (det2_nonneg_nondecreasing _ _ _ _ _ _ _ _ _ _ _ H_vanish H_r2 H_det2 min_one_is_in_base_interval H_r1 
                                         (proj1 H_r1)).
    realify_Q_goal; apply (f_equal2 Rdiv); ring... 
  (* END 0<=Det2, SPLIT 1 *)

  (* 0<=Det2, SPLIT 2 (2/4 OF TOTAL) *)
  (* q is increasing with r2 fixed, so we prove q(r1,r2)<=q(1,r2)<=0 *)
  apply Rle_trans with (((Qplus a c)*r2+(Qplus b d))/((Qplus e g)*r2+(Qplus f h)))%R.
   (* This is the subgoal generated by Rle trans. Back to: q(r1,r2)<=q(1,r2) *)
   stepr ((a*1*r2+b*1+c*r2+d)/(e*1*r2+f*1+g*r2+h))%R.
    apply (det2_nonneg_nondecreasing _ _ _ _ _ _ _ _ _ _ _ H_vanish H_r2 H_det2 H_r1 one_is_in_base_interval
                                         (proj2 H_r1)).
    realify_Q_goal; apply (f_equal2 Rdiv); ring... 

   destruct (Qle_dec_weak 0 ((a+c)*(f+h)-(b+d)*(e+g))) as [H_det|H_det].
    (* q(1,r2)<=q(1,1) *)
    apply Rle_trans with (((a+c)+(b+d))/((e+g)+(f+h)))%R.
     stepr (((Qplus a c)*1+(Qplus b d))/((Qplus e g)*(1)+(Qplus f h)))%R.
      apply (det_nonneg_nondecreasing (a+c) (b+d) (e+g) (f+h) r2 (1)%R H_vanish2 H_det H_r2 one_is_in_base_interval
                                         (proj2 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
     rationalify_R; apply Incl_M_L_unfolded_auxiliary_6; trivial. 
      ring_exact_Q H_efgh4.
      ring_exact_Q H8...
    (* q(1,r2)<=q(1,-1) *)
    apply Rle_trans with (((b+d)-(a+c))/((f+h)-(e+g)))%R.
     stepr (((Qplus a c)*(-1)+(Qplus b d))/((Qplus e g)*(-1)+(Qplus f h)))%R.
      apply (det_nonpos_nonincreasing (a+c) (b+d) (e+g) (f+h) (-1)%R r2 H_vanish2 H_det min_one_is_in_base_interval H_r2 (proj1 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 

     rationalify_R; apply Incl_M_L_unfolded_auxiliary_8; trivial. 
      ring_exact_Q H6...
  (* END 0<=Det2, SPLIT 2 *)

  (* Det2<=0, SPLIT 1 (3/4 OF TOTAL) *)
  (* q is decreasing with r2 fixed, so we prove -1<=q(1,r2)<= q(r1,r2) *)
  apply Rle_trans with (((Qplus a c)*r2+(Qplus b d))/((Qplus e g)*r2+(Qplus f h)))%R.

   destruct (Qle_dec_weak 0 ((a+c)*(f+h)-(b+d)*(e+g))) as [H_det|H_det].
    (* q(1,-1)<=q(1,r2) *)
    apply Rle_trans with (((b+d)-(a+c))/((f+h)-(e+g)))%R.

     rationalify_R; apply Incl_M_L_unfolded_auxiliary_5; trivial. 
      ring_exact_Q H5...
     stepl (((Qplus a c)*(-1)+(Qplus b d))/((Qplus e g)*(-1)+(Qplus f h)))%R.
      apply (det_nonneg_nondecreasing (a+c) (b+d) (e+g) (f+h) (-1)%R r2 H_vanish2 H_det min_one_is_in_base_interval H_r2 (proj1 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
    (* q(1,1)<=q(1,r2) *)
    apply Rle_trans with (((a+c)+(b+d))/((e+g)+(f+h)))%R.
     rationalify_R; apply Incl_M_L_unfolded_auxiliary_7; trivial. 
      ring_exact_Q H_efgh4.
      ring_exact_Q H7...
     stepl (((Qplus a c)*1+(Qplus b d))/((Qplus e g)*(1)+(Qplus f h)))%R.
      apply (det_nonpos_nonincreasing (a+c) (b+d) (e+g) (f+h) r2 (1)%R H_vanish2 H_det H_r2 one_is_in_base_interval
                                         (proj2 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
   (* This is the subgoal generated by Rle trans. Back to: q(1,r2)<=q(r1,r2) *)
   stepl ((a*1*r2+b*1+c*r2+d)/(e*1*r2+f*1+g*r2+h))%R.
    apply (det2_nonpos_nonincreasing _ _ _ _ _ _ _ _ _ _ _ H_vanish H_r2 H_det2 H_r1 one_is_in_base_interval
                                         (proj2 H_r1)).
    realify_Q_goal; apply (f_equal2 Rdiv); ring... 
  (* END Det2<=0, SPLIT 1 *)

  (* Det2<=0, SPLIT 2 (4/4 OF TOTAL) *)
  (* q is decreasing with r2 fixed, so we prove q(r1,r2)<=q(-1,r2)<=0 *)
  apply Rle_trans with (((Qminus c a)*r2+(Qminus d b))/((Qminus g e)*r2+(Qminus h f)))%R.
   (* This is the subgoal generated by Rle trans. Back to: q(r1,r2)<=q(-1,r2) *)
   stepr ((a*(-1)*r2+b*(-1)+c*r2+d)/(e*(-1)*r2+f*(-1)+g*r2+h))%R.
    apply (det2_nonpos_nonincreasing _ _ _ _ _ _ _ _ _ _ _ H_vanish H_r2 H_det2 min_one_is_in_base_interval H_r1
                                         (proj1 H_r1)).
    realify_Q_goal; apply (f_equal2 Rdiv); ring...

   destruct (Qle_dec_weak 0 ((c-a)*(h-f)-(d-b)*(g-e))) as [H_det|H_det].
    (* q(-1,r2)<=q(-1,1) *)
    apply Rle_trans with (((c-a)+(d-b))/((g-e)+(h-f)))%R.

     stepr (((Qminus c a)*1+(Qminus d b))/((Qminus g e)*1+(Qminus h f)))%R.
      apply (det_nonneg_nondecreasing (c-a) (d-b) (g-e) (h-f) r2 (1)%R H_vanish1 H_det H_r2 one_is_in_base_interval (proj2 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring...

     rationalify_R; apply Incl_M_L_unfolded_auxiliary_6; trivial. 
      ring_exact_Q H_efgh2.
      ring_exact_Q H4...
    (* q(-1,r2)<=q(-1,-1) *)
    apply Rle_trans with (((a-c)+(d-b))/((e-g)+(h-f)))%R.
     stepr (((Qminus c a)*(-1)+(Qminus d b))/((Qminus g e)*(-1)+(Qminus h f)))%R.
      apply (det_nonpos_nonincreasing (c-a) (d-b) (g-e) (h-f) (-1)%R r2 H_vanish1 H_det min_one_is_in_base_interval H_r2 (proj1 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring...
     rationalify_R; apply Incl_M_L_unfolded_auxiliary_6; trivial. 
      ring_exact_Q H_efgh1.
      ring_exact_Q H2...
  (* END Det2<=0, SPLIT 2 *)
Qed.

(* The proof of the following two lemmas is copy-pasted from the
above, only we have to change [Incl_M_L_unfolded_auxiliary_?] to
[Incl_M_R_unfolded_auxiliary_?], and the digit-related values after
that accordingly. *)

Lemma Incl_T_R_unfolded:forall xi r1 r2,(-1<=r1<=1)%R->(-1<=r2<=1)%R->Incl_T xi RR -> (0<=as_Tensor xi r1 r2<=1)%R.
Proof.
 intros (((a,b),(c,d)),((e,f),(g,h))) r1 r2 H_r1 H_r2; unfold as_Tensor, Incl_T, map_digits, fst, snd;
 replace 3%Z with (2+1)%Z; trivial; rewrite (Z_to_Qplus 2 1);
 intros [H_vanish [H1 [H2 [H3 [H4 [H5 [H6 [H7 H8]]]]]]]];
 generalize (Bounded_T_e_mf_mg_h_nonzero _ _ _ _ _ _ _ _ H_vanish); 
 generalize (Bounded_T_me_mf_g_h_nonzero _ _ _ _ _ _ _ _ H_vanish); 
 generalize (Bounded_T_me_f_mg_h_nonzero _ _ _ _ _ _ _ _ H_vanish); 
 generalize (Bounded_T_e_f_g_h_nonzero _ _ _ _ _ _ _ _ H_vanish); intros H_efgh4 H_efgh3 H_efgh2 H_efgh1;
 generalize (Bounded_T_M_1 _ _ _ _ _ _ _ _ H_vanish);
 generalize (Bounded_T_M_2 _ _ _ _ _ _ _ _ H_vanish); intros H_vanish2 H_vanish1.

 destruct (Rle_dec_weak 0 ((a*r2+b)*(g*r2+h)-(c*r2+d)*(e*r2+f))) as [H_det2|H_det2];
 split.
  (* 0<=Det2, SPLIT 1 (1/4 OF TOTAL) *)
  (* q is increasing with r2 fixed, so we prove -1<=q(-1,r2)<= q(r1,r2) *)
  apply Rle_trans with (((Qminus c a)*r2+(Qminus d b))/((Qminus g e)*r2+(Qminus h f)))%R.

   destruct (Qle_dec_weak 0 ((c-a)*(h-f)-(d-b)*(g-e))) as [H_det|H_det].
    (* q(-1,-1)<=q(-1,r2) *)
    apply Rle_trans with (((a-c)+(d-b))/((e-g)+(h-f)))%R.
     rationalify_R; apply Incl_M_R_unfolded_auxiliary_7; trivial.
       ring_exact_Q H_efgh1.
       ring_exact_Q H1...
      stepl (((Qminus c a)*(-1)+(Qminus d b))/((Qminus g e)*(-1)+(Qminus h f)))%R.
      apply (det_nonneg_nondecreasing (c-a) (d-b) (g-e) (h-f) (-1)%R r2 H_vanish1 H_det min_one_is_in_base_interval H_r2 (proj1 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
    (* q(-1,1)<=q(-1,r2) *)
    apply Rle_trans with (((c-a)+(d-b))/((g-e)+(h-f)))%R.
     rationalify_R; apply Incl_M_R_unfolded_auxiliary_7; trivial. 
       ring_exact_Q H_efgh2.
       ring_exact_Q H3...
     stepl (((Qminus c a)*1+(Qminus d b))/((Qminus g e)*1+(Qminus h f)))%R.
      apply (det_nonpos_nonincreasing (c-a) (d-b) (g-e) (h-f) r2 (1)%R H_vanish1 H_det H_r2 one_is_in_base_interval (proj2 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
   (* This is the subgoal generated by Rle trans. Back to: q(-1,r2)<=q(r1,r2) *)
   stepl ((a*(-1)*r2+b*(-1)+c*r2+d)/(e*(-1)*r2+f*(-1)+g*r2+h))%R.
    apply (det2_nonneg_nondecreasing _ _ _ _ _ _ _ _ _ _ _ H_vanish H_r2 H_det2 min_one_is_in_base_interval H_r1 
                                         (proj1 H_r1)).
    realify_Q_goal; apply (f_equal2 Rdiv); ring... 
  (* END 0<=Det2, SPLIT 1 *)

  (* 0<=Det2, SPLIT 2 (2/4 OF TOTAL) *)
  (* q is increasing with r2 fixed, so we prove q(r1,r2)<=q(1,r2)<=0 *)
  apply Rle_trans with (((Qplus a c)*r2+(Qplus b d))/((Qplus e g)*r2+(Qplus f h)))%R.
   (* This is the subgoal generated by Rle trans. Back to: q(r1,r2)<=q(1,r2) *)
   stepr ((a*1*r2+b*1+c*r2+d)/(e*1*r2+f*1+g*r2+h))%R.
    apply (det2_nonneg_nondecreasing _ _ _ _ _ _ _ _ _ _ _ H_vanish H_r2 H_det2 H_r1 one_is_in_base_interval
                                         (proj2 H_r1)).
    realify_Q_goal; apply (f_equal2 Rdiv); ring... 

   destruct (Qle_dec_weak 0 ((a+c)*(f+h)-(b+d)*(e+g))) as [H_det|H_det].
    (* q(1,r2)<=q(1,1) *)
    apply Rle_trans with (((a+c)+(b+d))/((e+g)+(f+h)))%R.
     stepr (((Qplus a c)*1+(Qplus b d))/((Qplus e g)*(1)+(Qplus f h)))%R.
      apply (det_nonneg_nondecreasing (a+c) (b+d) (e+g) (f+h) r2 (1)%R H_vanish2 H_det H_r2 one_is_in_base_interval
                                         (proj2 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
     rationalify_R; apply Incl_M_R_unfolded_auxiliary_6; trivial. 
      ring_exact_Q H_efgh4.
      ring_exact_Q H8...
    (* q(1,r2)<=q(1,-1) *)
    apply Rle_trans with (((b+d)-(a+c))/((f+h)-(e+g)))%R.
     stepr (((Qplus a c)*(-1)+(Qplus b d))/((Qplus e g)*(-1)+(Qplus f h)))%R.
      apply (det_nonpos_nonincreasing (a+c) (b+d) (e+g) (f+h) (-1)%R r2 H_vanish2 H_det min_one_is_in_base_interval H_r2 (proj1 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 

     rationalify_R; apply Incl_M_R_unfolded_auxiliary_8; trivial. 
      ring_exact_Q H6...
  (* END 0<=Det2, SPLIT 2 *)

  (* Det2<=0, SPLIT 1 (3/4 OF TOTAL) *)
  (* q is decreasing with r2 fixed, so we prove -1<=q(1,r2)<= q(r1,r2) *)
  apply Rle_trans with (((Qplus a c)*r2+(Qplus b d))/((Qplus e g)*r2+(Qplus f h)))%R.

   destruct (Qle_dec_weak 0 ((a+c)*(f+h)-(b+d)*(e+g))) as [H_det|H_det].
    (* q(1,-1)<=q(1,r2) *)
    apply Rle_trans with (((b+d)-(a+c))/((f+h)-(e+g)))%R.

     rationalify_R; apply Incl_M_R_unfolded_auxiliary_5; trivial. 
      ring_exact_Q H5...
     stepl (((Qplus a c)*(-1)+(Qplus b d))/((Qplus e g)*(-1)+(Qplus f h)))%R.
      apply (det_nonneg_nondecreasing (a+c) (b+d) (e+g) (f+h) (-1)%R r2 H_vanish2 H_det min_one_is_in_base_interval H_r2 (proj1 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
    (* q(1,1)<=q(1,r2) *)
    apply Rle_trans with (((a+c)+(b+d))/((e+g)+(f+h)))%R.
     rationalify_R; apply Incl_M_R_unfolded_auxiliary_7; trivial. 
      ring_exact_Q H_efgh4.
      ring_exact_Q H7...
     stepl (((Qplus a c)*1+(Qplus b d))/((Qplus e g)*(1)+(Qplus f h)))%R.
      apply (det_nonpos_nonincreasing (a+c) (b+d) (e+g) (f+h) r2 (1)%R H_vanish2 H_det H_r2 one_is_in_base_interval
                                         (proj2 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
   (* This is the subgoal generated by Rle trans. Back to: q(1,r2)<=q(r1,r2) *)
   stepl ((a*1*r2+b*1+c*r2+d)/(e*1*r2+f*1+g*r2+h))%R.
    apply (det2_nonpos_nonincreasing _ _ _ _ _ _ _ _ _ _ _ H_vanish H_r2 H_det2 H_r1 one_is_in_base_interval
                                         (proj2 H_r1)).
    realify_Q_goal; apply (f_equal2 Rdiv); ring... 
  (* END Det2<=0, SPLIT 1 *)

  (* Det2<=0, SPLIT 2 (4/4 OF TOTAL) *)
  (* q is decreasing with r2 fixed, so we prove q(r1,r2)<=q(-1,r2)<=0 *)
  apply Rle_trans with (((Qminus c a)*r2+(Qminus d b))/((Qminus g e)*r2+(Qminus h f)))%R.
   (* This is the subgoal generated by Rle trans. Back to: q(r1,r2)<=q(-1,r2) *)
   stepr ((a*(-1)*r2+b*(-1)+c*r2+d)/(e*(-1)*r2+f*(-1)+g*r2+h))%R.
    apply (det2_nonpos_nonincreasing _ _ _ _ _ _ _ _ _ _ _ H_vanish H_r2 H_det2 min_one_is_in_base_interval H_r1
                                         (proj1 H_r1)).
    realify_Q_goal; apply (f_equal2 Rdiv); ring...

   destruct (Qle_dec_weak 0 ((c-a)*(h-f)-(d-b)*(g-e))) as [H_det|H_det].
    (* q(-1,r2)<=q(-1,1) *)
    apply Rle_trans with (((c-a)+(d-b))/((g-e)+(h-f)))%R.

     stepr (((Qminus c a)*1+(Qminus d b))/((Qminus g e)*1+(Qminus h f)))%R.
      apply (det_nonneg_nondecreasing (c-a) (d-b) (g-e) (h-f) r2 (1)%R H_vanish1 H_det H_r2 one_is_in_base_interval (proj2 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring...

     rationalify_R; apply Incl_M_R_unfolded_auxiliary_6; trivial. 
      ring_exact_Q H_efgh2.
      ring_exact_Q H4...
    (* q(-1,r2)<=q(-1,-1) *)
    apply Rle_trans with (((a-c)+(d-b))/((e-g)+(h-f)))%R.
     stepr (((Qminus c a)*(-1)+(Qminus d b))/((Qminus g e)*(-1)+(Qminus h f)))%R.
      apply (det_nonpos_nonincreasing (c-a) (d-b) (g-e) (h-f) (-1)%R r2 H_vanish1 H_det min_one_is_in_base_interval H_r2 (proj1 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring...
     rationalify_R; apply Incl_M_R_unfolded_auxiliary_6; trivial. 
      ring_exact_Q H_efgh1.
      ring_exact_Q H2...
  (* END Det2<=0, SPLIT 2 *)
Qed.

Lemma Incl_T_M_unfolded:forall xi r1 r2,(-1<=r1<=1)%R->(-1<=r2<=1)%R->Incl_T xi MM -> ((-1)/3<=as_Tensor xi r1 r2<=1/3)%R.
Proof.
 intros (((a,b),(c,d)),((e,f),(g,h))) r1 r2 H_r1 H_r2; unfold as_Tensor, Incl_T, map_digits, fst, snd;
 replace 3%Z with (2+1)%Z; trivial; rewrite (Z_to_Qplus 2 1);
 intros [H_vanish [H1 [H2 [H3 [H4 [H5 [H6 [H7 H8]]]]]]]];
 generalize (Bounded_T_e_mf_mg_h_nonzero _ _ _ _ _ _ _ _ H_vanish); 
 generalize (Bounded_T_me_mf_g_h_nonzero _ _ _ _ _ _ _ _ H_vanish); 
 generalize (Bounded_T_me_f_mg_h_nonzero _ _ _ _ _ _ _ _ H_vanish); 
 generalize (Bounded_T_e_f_g_h_nonzero _ _ _ _ _ _ _ _ H_vanish); intros H_efgh4 H_efgh3 H_efgh2 H_efgh1;
 generalize (Bounded_T_M_1 _ _ _ _ _ _ _ _ H_vanish);
 generalize (Bounded_T_M_2 _ _ _ _ _ _ _ _ H_vanish); intros H_vanish2 H_vanish1.

 destruct (Rle_dec_weak 0 ((a*r2+b)*(g*r2+h)-(c*r2+d)*(e*r2+f))) as [H_det2|H_det2];
 split.
  (* 0<=Det2, SPLIT 1 (1/4 OF TOTAL) *)
  (* q is increasing with r2 fixed, so we prove -1<=q(-1,r2)<= q(r1,r2) *)
  apply Rle_trans with (((Qminus c a)*r2+(Qminus d b))/((Qminus g e)*r2+(Qminus h f)))%R.

   destruct (Qle_dec_weak 0 ((c-a)*(h-f)-(d-b)*(g-e))) as [H_det|H_det].
    (* q(-1,-1)<=q(-1,r2) *)
    apply Rle_trans with (((a-c)+(d-b))/((e-g)+(h-f)))%R.
     rationalify_R; apply Incl_M_M_unfolded_auxiliary_7; trivial.
       ring_exact_Q H_efgh1.
       ring_exact_Q H1...
      stepl (((Qminus c a)*(-1)+(Qminus d b))/((Qminus g e)*(-1)+(Qminus h f)))%R.
      apply (det_nonneg_nondecreasing (c-a) (d-b) (g-e) (h-f) (-1)%R r2 H_vanish1 H_det min_one_is_in_base_interval H_r2 (proj1 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
    (* q(-1,1)<=q(-1,r2) *)
    apply Rle_trans with (((c-a)+(d-b))/((g-e)+(h-f)))%R.
     rationalify_R; apply Incl_M_M_unfolded_auxiliary_7; trivial. 
       ring_exact_Q H_efgh2.
       ring_exact_Q H3...
     stepl (((Qminus c a)*1+(Qminus d b))/((Qminus g e)*1+(Qminus h f)))%R.
      apply (det_nonpos_nonincreasing (c-a) (d-b) (g-e) (h-f) r2 (1)%R H_vanish1 H_det H_r2 one_is_in_base_interval (proj2 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
   (* This is the subgoal generated by Rle trans. Back to: q(-1,r2)<=q(r1,r2) *)
   stepl ((a*(-1)*r2+b*(-1)+c*r2+d)/(e*(-1)*r2+f*(-1)+g*r2+h))%R.
    apply (det2_nonneg_nondecreasing _ _ _ _ _ _ _ _ _ _ _ H_vanish H_r2 H_det2 min_one_is_in_base_interval H_r1 
                                         (proj1 H_r1)).
    realify_Q_goal; apply (f_equal2 Rdiv); ring... 
  (* END 0<=Det2, SPLIT 1 *)

  (* 0<=Det2, SPLIT 2 (2/4 OF TOTAL) *)
  (* q is increasing with r2 fixed, so we prove q(r1,r2)<=q(1,r2)<=0 *)
  apply Rle_trans with (((Qplus a c)*r2+(Qplus b d))/((Qplus e g)*r2+(Qplus f h)))%R.
   (* This is the subgoal generated by Rle trans. Back to: q(r1,r2)<=q(1,r2) *)
   stepr ((a*1*r2+b*1+c*r2+d)/(e*1*r2+f*1+g*r2+h))%R.
    apply (det2_nonneg_nondecreasing _ _ _ _ _ _ _ _ _ _ _ H_vanish H_r2 H_det2 H_r1 one_is_in_base_interval
                                         (proj2 H_r1)).
    realify_Q_goal; apply (f_equal2 Rdiv); ring... 

   destruct (Qle_dec_weak 0 ((a+c)*(f+h)-(b+d)*(e+g))) as [H_det|H_det].
    (* q(1,r2)<=q(1,1) *)
    apply Rle_trans with (((a+c)+(b+d))/((e+g)+(f+h)))%R.
     stepr (((Qplus a c)*1+(Qplus b d))/((Qplus e g)*(1)+(Qplus f h)))%R.
      apply (det_nonneg_nondecreasing (a+c) (b+d) (e+g) (f+h) r2 (1)%R H_vanish2 H_det H_r2 one_is_in_base_interval
                                         (proj2 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
     rationalify_R; apply Incl_M_M_unfolded_auxiliary_6; trivial. 
      ring_exact_Q H_efgh4.
      ring_exact_Q H8...
    (* q(1,r2)<=q(1,-1) *)
    apply Rle_trans with (((b+d)-(a+c))/((f+h)-(e+g)))%R.
     stepr (((Qplus a c)*(-1)+(Qplus b d))/((Qplus e g)*(-1)+(Qplus f h)))%R.
      apply (det_nonpos_nonincreasing (a+c) (b+d) (e+g) (f+h) (-1)%R r2 H_vanish2 H_det min_one_is_in_base_interval H_r2 (proj1 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 

     rationalify_R; apply Incl_M_M_unfolded_auxiliary_8; trivial. 
      ring_exact_Q H6...
  (* END 0<=Det2, SPLIT 2 *)

  (* Det2<=0, SPLIT 1 (3/4 OF TOTAL) *)
  (* q is decreasing with r2 fixed, so we prove -1<=q(1,r2)<= q(r1,r2) *)
  apply Rle_trans with (((Qplus a c)*r2+(Qplus b d))/((Qplus e g)*r2+(Qplus f h)))%R.

   destruct (Qle_dec_weak 0 ((a+c)*(f+h)-(b+d)*(e+g))) as [H_det|H_det].
    (* q(1,-1)<=q(1,r2) *)
    apply Rle_trans with (((b+d)-(a+c))/((f+h)-(e+g)))%R.

     rationalify_R; apply Incl_M_M_unfolded_auxiliary_5; trivial. 
      ring_exact_Q H5...
     stepl (((Qplus a c)*(-1)+(Qplus b d))/((Qplus e g)*(-1)+(Qplus f h)))%R.
      apply (det_nonneg_nondecreasing (a+c) (b+d) (e+g) (f+h) (-1)%R r2 H_vanish2 H_det min_one_is_in_base_interval H_r2 (proj1 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
    (* q(1,1)<=q(1,r2) *)
    apply Rle_trans with (((a+c)+(b+d))/((e+g)+(f+h)))%R.
     rationalify_R; apply Incl_M_M_unfolded_auxiliary_7; trivial. 
      ring_exact_Q H_efgh4.
      ring_exact_Q H7...
     stepl (((Qplus a c)*1+(Qplus b d))/((Qplus e g)*(1)+(Qplus f h)))%R.
      apply (det_nonpos_nonincreasing (a+c) (b+d) (e+g) (f+h) r2 (1)%R H_vanish2 H_det H_r2 one_is_in_base_interval
                                         (proj2 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring... 
   (* This is the subgoal generated by Rle trans. Back to: q(1,r2)<=q(r1,r2) *)
   stepl ((a*1*r2+b*1+c*r2+d)/(e*1*r2+f*1+g*r2+h))%R.
    apply (det2_nonpos_nonincreasing _ _ _ _ _ _ _ _ _ _ _ H_vanish H_r2 H_det2 H_r1 one_is_in_base_interval
                                         (proj2 H_r1)).
    realify_Q_goal; apply (f_equal2 Rdiv); ring... 
  (* END Det2<=0, SPLIT 1 *)

  (* Det2<=0, SPLIT 2 (4/4 OF TOTAL) *)
  (* q is decreasing with r2 fixed, so we prove q(r1,r2)<=q(-1,r2)<=0 *)
  apply Rle_trans with (((Qminus c a)*r2+(Qminus d b))/((Qminus g e)*r2+(Qminus h f)))%R.
   (* This is the subgoal generated by Rle trans. Back to: q(r1,r2)<=q(-1,r2) *)
   stepr ((a*(-1)*r2+b*(-1)+c*r2+d)/(e*(-1)*r2+f*(-1)+g*r2+h))%R.
    apply (det2_nonpos_nonincreasing _ _ _ _ _ _ _ _ _ _ _ H_vanish H_r2 H_det2 min_one_is_in_base_interval H_r1
                                         (proj1 H_r1)).
    realify_Q_goal; apply (f_equal2 Rdiv); ring...

   destruct (Qle_dec_weak 0 ((c-a)*(h-f)-(d-b)*(g-e))) as [H_det|H_det].
    (* q(-1,r2)<=q(-1,1) *)
    apply Rle_trans with (((c-a)+(d-b))/((g-e)+(h-f)))%R.

     stepr (((Qminus c a)*1+(Qminus d b))/((Qminus g e)*1+(Qminus h f)))%R.
      apply (det_nonneg_nondecreasing (c-a) (d-b) (g-e) (h-f) r2 (1)%R H_vanish1 H_det H_r2 one_is_in_base_interval (proj2 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring...

     rationalify_R; apply Incl_M_M_unfolded_auxiliary_6; trivial. 
      ring_exact_Q H_efgh2.
      ring_exact_Q H4...
    (* q(-1,r2)<=q(-1,-1) *)
    apply Rle_trans with (((a-c)+(d-b))/((e-g)+(h-f)))%R.
     stepr (((Qminus c a)*(-1)+(Qminus d b))/((Qminus g e)*(-1)+(Qminus h f)))%R.
      apply (det_nonpos_nonincreasing (c-a) (d-b) (g-e) (h-f) (-1)%R r2 H_vanish1 H_det min_one_is_in_base_interval H_r2 (proj1 H_r2)).
      realify_Q_goal; apply (f_equal2 Rdiv); ring...
     rationalify_R; apply Incl_M_M_unfolded_auxiliary_6; trivial. 
      ring_exact_Q H_efgh1.
      ring_exact_Q H2...
  (* END Det2<=0, SPLIT 2 *)
Qed.


Lemma Incl_T_L_folded: forall xi, (forall r1 r2,(-1 <= r1 <= 1)%R -> (-1 <= r2 <= 1)%R -> denom_nonvanishing_T xi r1 r2) ->
     (forall r1 r2,(-1 <= r1 <= 1)%R -> (-1 <= r2 <= 1)%R -> (-1 <= as_Tensor xi r1 r2 <= 0)%R) -> Incl_T xi LL.
Proof.
 intros (((a,b),(c,d)),((e,f),(g,h))) H_denom H_xi.
 assert (H_bounded:=(denom_nonvanishing_T_Bounded_T _ H_denom)).
 unfold as_Tensor in H_xi; simpl in H_xi.
 assert (H_efgh1:=Bounded_T_e_mf_mg_h_nonzero _ _ _ _ _ _ _ _ H_bounded); 
 assert (H_efgh2:=Bounded_T_me_mf_g_h_nonzero _ _ _ _ _ _ _ _ H_bounded); 
 assert (H_efgh3:=Bounded_T_me_f_mg_h_nonzero _ _ _ _ _ _ _ _ H_bounded); 
 assert (H_efgh4:=Bounded_T_e_f_g_h_nonzero _ _ _ _ _ _ _ _ H_bounded);
 assert (H_h:=Bounded_T_nonzero _ _ _ _ _ _ _ _ H_bounded).
 unfold Incl_T, map_digits, fst, snd; qZ_numerals; repeat split; trivial.
  (* Refining 1 *)
  destruct (not_Qeq_inf _ _ H_efgh1) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh1m.
   (* 1l *) 
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + - b + - c + d)%R); apply Rdiv_Rmult_pos_neg_Rle'; auto; try Fourier.fourier;
   stepl (-1)%R; [|field]; stepr ((a*(-1)*(-1)+b*(-1)+c*(-1)+d)/(e*(-1)*(-1)+f*(-1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh1];
   exact (proj1 (H_xi (-1)%R (-1)%R min_one_is_in_base_interval min_one_is_in_base_interval)).
   (* 1r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + - b + - c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepl (-1)%R; [|field]; stepr ((a*(-1)*(-1)+b*(-1)+c*(-1)+d)/(e*(-1)*(-1)+f*(-1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh1];
   exact (proj1 (H_xi (-1)%R (-1)%R min_one_is_in_base_interval min_one_is_in_base_interval)).
  (* Refining 2 *)
  destruct (not_Qeq_inf _ _ H_efgh1) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh1m.
   (* 2l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + - b + - c + d)%R); apply Rdiv_Rmult_neg_pos_Rle'; auto; try Fourier.fourier;
   stepr R0; [|field]; stepl ((a*(-1)*(-1)+b*(-1)+c*(-1)+d)/(e*(-1)*(-1)+f*(-1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh1];
   exact (proj2 (H_xi (-1)%R (-1)%R min_one_is_in_base_interval min_one_is_in_base_interval)).
   (* 2r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + - b + - c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepr R0; [|field]; stepl ((a*(-1)*(-1)+b*(-1)+c*(-1)+d)/(e*(-1)*(-1)+f*(-1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh1];
   exact (proj2 (H_xi (-1)%R (-1)%R min_one_is_in_base_interval min_one_is_in_base_interval)).
  (* Refining 3 *)
  destruct (not_Qeq_inf _ _ H_efgh2) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh2m.
   (* 3l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + - b +  c + d)%R); apply Rdiv_Rmult_pos_neg_Rle'; auto; try Fourier.fourier;
   stepl (-1)%R; [|field]; stepr ((a*(-1)*(1)+b*(-1)+c*(1)+d)/(e*(-1)*(1)+f*(-1)+g*(1)+h))%R; [|field; ring_exact_R H_efgh2];
   exact (proj1 (H_xi (-1)%R (1)%R min_one_is_in_base_interval one_is_in_base_interval)).
   (* 3r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + - b + c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepl (-1)%R; [|field]; stepr ((a*(-1)*(1)+b*(-1)+c*(1)+d)/(e*(-1)*(1)+f*(-1)+g*(1)+h))%R; [|field; ring_exact_R H_efgh2];
   exact (proj1 (H_xi (-1)%R (1)%R min_one_is_in_base_interval one_is_in_base_interval)).
  (* Refining 4 *)
  destruct (not_Qeq_inf _ _ H_efgh2) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh2m.
   (* 4l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + - b +  c + d)%R); apply Rdiv_Rmult_neg_pos_Rle'; auto; try Fourier.fourier;
   stepr R0; [|field]; stepl ((a*(-1)*(1)+b*(-1)+c*(1)+d)/(e*(-1)*(1)+f*(-1)+g*(1)+h))%R; [|field; ring_exact_R H_efgh2];
   exact (proj2 (H_xi (-1)%R (1)%R min_one_is_in_base_interval one_is_in_base_interval)).
   (* 4r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + - b + c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepr R0; [|field]; stepl ((a*(-1)*(1)+b*(-1)+c*(1)+d)/(e*(-1)*(1)+f*(-1)+g*(1)+h))%R; [|field; ring_exact_R H_efgh2];
   exact (proj2 (H_xi (-1)%R (1)%R min_one_is_in_base_interval one_is_in_base_interval)).
  (* Refining 5 *)
  destruct (not_Qeq_inf _ _ H_efgh3) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh3m.
   (* 5l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a +  b + -c + d)%R); apply Rdiv_Rmult_pos_neg_Rle'; auto; try Fourier.fourier;
   stepl (-1)%R; [|field]; stepr ((a*(1)*(-1)+b*(1)+c*(-1)+d)/(e*(1)*(-1)+f*(1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh3];
   exact (proj1 (H_xi (1)%R (-1)%R one_is_in_base_interval min_one_is_in_base_interval)).
   (* 5r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a +  b + -c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepl (-1)%R; [|field]; stepr ((a*(1)*(-1)+b*(1)+c*(-1)+d)/(e*(1)*(-1)+f*(1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh3];
   exact (proj1 (H_xi (1)%R (-1)%R one_is_in_base_interval min_one_is_in_base_interval)).
  (* Refining 6 *)
  destruct (not_Qeq_inf _ _ H_efgh3) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh3m.
   (* 6l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + b +  -c + d)%R); apply Rdiv_Rmult_neg_pos_Rle'; auto; try Fourier.fourier;
   stepr R0; [|field];  stepl ((a*(1)*(-1)+b*(1)+c*(-1)+d)/(e*(1)*(-1)+f*(1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh3];
   exact (proj2 (H_xi (1)%R (-1)%R one_is_in_base_interval min_one_is_in_base_interval)).
   (* 6r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a +  b + -c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepr R0; [|field]; stepl ((a*(1)*(-1)+b*(1)+c*(-1)+d)/(e*(1)*(-1)+f*(1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh3];
   exact (proj2 (H_xi (1)%R (-1)%R one_is_in_base_interval min_one_is_in_base_interval)).
  (* Refining 7 *)
  destruct (not_Qeq_inf _ _ H_efgh4) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh4m.
   (* 7l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a +  b + c + d)%R); apply Rdiv_Rmult_pos_neg_Rle'; auto; try Fourier.fourier;
   stepl (-1)%R; [|field]; stepr ((a*1*1+b*1+c*1+d)/(e*1*1+f*1+g*1+h))%R; [|field; ring_exact_R H_efgh4];
   exact (proj1 (H_xi (1)%R (1)%R one_is_in_base_interval one_is_in_base_interval)).
   (* 7r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a +  b + c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepl (-1)%R; [|field]; stepr ((a*1*1+b*1+c*1+d)/(e*1*1+f*1+g*1+h))%R; [|field; ring_exact_R H_efgh4];
   exact (proj1 (H_xi (1)%R (1)%R one_is_in_base_interval one_is_in_base_interval)).
  (* Refining 8 *)
  destruct (not_Qeq_inf _ _ H_efgh4) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh4m.
   (* 8l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + b +  c + d)%R); apply Rdiv_Rmult_neg_pos_Rle'; auto; try Fourier.fourier;
   stepr R0; [|field]; stepl ((a*1*1+b*1+c*1+d)/(e*1*1+f*1+g*1+h))%R; [|field; ring_exact_R H_efgh4];
   exact (proj2 (H_xi (1)%R (1)%R one_is_in_base_interval one_is_in_base_interval)).
   (* 8r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a +  b + c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepr R0; [|field]; stepl ((a*1*1+b*1+c*1+d)/(e*1*1+f*1+g*1+h))%R; [|field; ring_exact_R H_efgh4];
   exact (proj2 (H_xi (1)%R (1)%R one_is_in_base_interval one_is_in_base_interval)).
Qed.

Lemma Incl_T_R_folded: forall xi, (forall r1 r2,(-1 <= r1 <= 1)%R -> (-1 <= r2 <= 1)%R -> denom_nonvanishing_T xi r1 r2) ->
     (forall r1 r2,(-1 <= r1 <= 1)%R -> (-1 <= r2 <= 1)%R -> (0 <= as_Tensor xi r1 r2 <= 1)%R) -> Incl_T xi RR.
Proof.
 intros (((a,b),(c,d)),((e,f),(g,h))) H_denom H_xi.
 assert (H_bounded:=(denom_nonvanishing_T_Bounded_T _ H_denom)).
 unfold as_Tensor in H_xi; simpl in H_xi.
 assert (H_efgh1:=Bounded_T_e_mf_mg_h_nonzero _ _ _ _ _ _ _ _ H_bounded); 
 assert (H_efgh2:=Bounded_T_me_mf_g_h_nonzero _ _ _ _ _ _ _ _ H_bounded); 
 assert (H_efgh3:=Bounded_T_me_f_mg_h_nonzero _ _ _ _ _ _ _ _ H_bounded); 
 assert (H_efgh4:=Bounded_T_e_f_g_h_nonzero _ _ _ _ _ _ _ _ H_bounded);
 assert (H_h:=Bounded_T_nonzero _ _ _ _ _ _ _ _ H_bounded).
 unfold Incl_T, map_digits, fst, snd; qZ_numerals; repeat split; trivial.
  (* Refining 1 *)
  destruct (not_Qeq_inf _ _ H_efgh1) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh1m.
   (* 1l *) 
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + - b + - c + d)%R); apply Rdiv_Rmult_pos_neg_Rle'; auto; try Fourier.fourier;
   stepl R0; [|field]; stepr ((a*(-1)*(-1)+b*(-1)+c*(-1)+d)/(e*(-1)*(-1)+f*(-1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh1];
   exact (proj1 (H_xi (-1)%R (-1)%R min_one_is_in_base_interval min_one_is_in_base_interval)).
   (* 1r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + - b + - c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepl R0; [|field]; stepr ((a*(-1)*(-1)+b*(-1)+c*(-1)+d)/(e*(-1)*(-1)+f*(-1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh1];
   exact (proj1 (H_xi (-1)%R (-1)%R min_one_is_in_base_interval min_one_is_in_base_interval)).
  (* Refining 2 *)
  destruct (not_Qeq_inf _ _ H_efgh1) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh1m.
   (* 2l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + - b + - c + d)%R); apply Rdiv_Rmult_neg_pos_Rle'; auto; try Fourier.fourier;
   stepr R1; [|field]; stepl ((a*(-1)*(-1)+b*(-1)+c*(-1)+d)/(e*(-1)*(-1)+f*(-1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh1];
   exact (proj2 (H_xi (-1)%R (-1)%R min_one_is_in_base_interval min_one_is_in_base_interval)).
   (* 2r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + - b + - c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepr R1; [|field]; stepl ((a*(-1)*(-1)+b*(-1)+c*(-1)+d)/(e*(-1)*(-1)+f*(-1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh1];
   exact (proj2 (H_xi (-1)%R (-1)%R min_one_is_in_base_interval min_one_is_in_base_interval)).
  (* Refining 3 *)
  destruct (not_Qeq_inf _ _ H_efgh2) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh2m.
   (* 3l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + - b +  c + d)%R); apply Rdiv_Rmult_pos_neg_Rle'; auto; try Fourier.fourier;
   stepl R0; [|field]; stepr ((a*(-1)*(1)+b*(-1)+c*(1)+d)/(e*(-1)*(1)+f*(-1)+g*(1)+h))%R; [|field; ring_exact_R H_efgh2];
   exact (proj1 (H_xi (-1)%R (1)%R min_one_is_in_base_interval one_is_in_base_interval)).
   (* 3r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + - b + c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepl R0; [|field]; stepr ((a*(-1)*(1)+b*(-1)+c*(1)+d)/(e*(-1)*(1)+f*(-1)+g*(1)+h))%R; [|field; ring_exact_R H_efgh2];
   exact (proj1 (H_xi (-1)%R (1)%R min_one_is_in_base_interval one_is_in_base_interval)).
  (* Refining 4 *)
  destruct (not_Qeq_inf _ _ H_efgh2) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh2m.
   (* 4l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + - b +  c + d)%R); apply Rdiv_Rmult_neg_pos_Rle'; auto; try Fourier.fourier;
   stepr R1; [|field]; stepl ((a*(-1)*(1)+b*(-1)+c*(1)+d)/(e*(-1)*(1)+f*(-1)+g*(1)+h))%R; [|field; ring_exact_R H_efgh2];
   exact (proj2 (H_xi (-1)%R (1)%R min_one_is_in_base_interval one_is_in_base_interval)).
   (* 4r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + - b + c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepr R1; [|field]; stepl ((a*(-1)*(1)+b*(-1)+c*(1)+d)/(e*(-1)*(1)+f*(-1)+g*(1)+h))%R; [|field; ring_exact_R H_efgh2];
   exact (proj2 (H_xi (-1)%R (1)%R min_one_is_in_base_interval one_is_in_base_interval)).
  (* Refining 5 *)
  destruct (not_Qeq_inf _ _ H_efgh3) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh3m.
   (* 5l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a +  b + -c + d)%R); apply Rdiv_Rmult_pos_neg_Rle'; auto; try Fourier.fourier;
   stepl R0; [|field]; stepr ((a*(1)*(-1)+b*(1)+c*(-1)+d)/(e*(1)*(-1)+f*(1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh3];
   exact (proj1 (H_xi (1)%R (-1)%R one_is_in_base_interval min_one_is_in_base_interval)).
   (* 5r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a +  b + -c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepl R0; [|field]; stepr ((a*(1)*(-1)+b*(1)+c*(-1)+d)/(e*(1)*(-1)+f*(1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh3];
   exact (proj1 (H_xi (1)%R (-1)%R one_is_in_base_interval min_one_is_in_base_interval)).
  (* Refining 6 *)
  destruct (not_Qeq_inf _ _ H_efgh3) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh3m.
   (* 6l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + b +  -c + d)%R); apply Rdiv_Rmult_neg_pos_Rle'; auto; try Fourier.fourier;
   stepr R1; [|field];  stepl ((a*(1)*(-1)+b*(1)+c*(-1)+d)/(e*(1)*(-1)+f*(1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh3];
   exact (proj2 (H_xi (1)%R (-1)%R one_is_in_base_interval min_one_is_in_base_interval)).
   (* 6r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a +  b + -c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepr R1; [|field]; stepl ((a*(1)*(-1)+b*(1)+c*(-1)+d)/(e*(1)*(-1)+f*(1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh3];
   exact (proj2 (H_xi (1)%R (-1)%R one_is_in_base_interval min_one_is_in_base_interval)).
  (* Refining 7 *)
  destruct (not_Qeq_inf _ _ H_efgh4) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh4m.
   (* 7l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a +  b + c + d)%R); apply Rdiv_Rmult_pos_neg_Rle'; auto; try Fourier.fourier;
   stepl R0; [|field]; stepr ((a*1*1+b*1+c*1+d)/(e*1*1+f*1+g*1+h))%R; [|field; ring_exact_R H_efgh4];
   exact (proj1 (H_xi (1)%R (1)%R one_is_in_base_interval one_is_in_base_interval)).
   (* 7r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a +  b + c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepl R0; [|field]; stepr ((a*1*1+b*1+c*1+d)/(e*1*1+f*1+g*1+h))%R; [|field; ring_exact_R H_efgh4];
   exact (proj1 (H_xi (1)%R (1)%R one_is_in_base_interval one_is_in_base_interval)).
  (* Refining 8 *)
  destruct (not_Qeq_inf _ _ H_efgh4) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh4m.
   (* 8l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + b +  c + d)%R); apply Rdiv_Rmult_neg_pos_Rle'; auto; try Fourier.fourier;
   stepr R1; [|field]; stepl ((a*1*1+b*1+c*1+d)/(e*1*1+f*1+g*1+h))%R; [|field; ring_exact_R H_efgh4];
   exact (proj2 (H_xi (1)%R (1)%R one_is_in_base_interval one_is_in_base_interval)).
   (* 8r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a +  b + c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepr R1; [|field]; stepl ((a*1*1+b*1+c*1+d)/(e*1*1+f*1+g*1+h))%R; [|field; ring_exact_R H_efgh4];
   exact (proj2 (H_xi (1)%R (1)%R one_is_in_base_interval one_is_in_base_interval)).
Qed.

Lemma Incl_T_M_folded: forall xi, (forall r1 r2,(-1 <= r1 <= 1)%R -> (-1 <= r2 <= 1)%R -> denom_nonvanishing_T xi r1 r2) ->
     (forall r1 r2,(-1 <= r1 <= 1)%R -> (-1 <= r2 <= 1)%R -> ((-1/3)<= as_Tensor xi r1 r2 <= 1/3)%R) -> Incl_T xi MM.
Proof.
 intros (((a,b),(c,d)),((e,f),(g,h))) H_denom H_xi.
 assert (H_bounded:=(denom_nonvanishing_T_Bounded_T _ H_denom)).
 unfold as_Tensor in H_xi; simpl in H_xi.
 assert (H_efgh1:=Bounded_T_e_mf_mg_h_nonzero _ _ _ _ _ _ _ _ H_bounded); 
 assert (H_efgh2:=Bounded_T_me_mf_g_h_nonzero _ _ _ _ _ _ _ _ H_bounded); 
 assert (H_efgh3:=Bounded_T_me_f_mg_h_nonzero _ _ _ _ _ _ _ _ H_bounded); 
 assert (H_efgh4:=Bounded_T_e_f_g_h_nonzero _ _ _ _ _ _ _ _ H_bounded);
 assert (H_h:=Bounded_T_nonzero _ _ _ _ _ _ _ _ H_bounded).
 unfold Incl_T, map_digits, fst, snd; qZ_numerals; repeat split; trivial.
  (* Refining 1 *)
  destruct (not_Qeq_inf _ _ H_efgh1) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh1m.
   (* 1l *) 
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + - b + - c + d)%R); apply Rdiv_Rmult_pos_neg_Rle'; auto; try Fourier.fourier;
   stepl ((-1)/3)%R; [|field]; stepr ((a*(-1)*(-1)+b*(-1)+c*(-1)+d)/(e*(-1)*(-1)+f*(-1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh1];
   exact (proj1 (H_xi (-1)%R (-1)%R min_one_is_in_base_interval min_one_is_in_base_interval)).
   (* 1r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + - b + - c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepl ((-1)/3)%R; [|field]; stepr ((a*(-1)*(-1)+b*(-1)+c*(-1)+d)/(e*(-1)*(-1)+f*(-1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh1];
   exact (proj1 (H_xi (-1)%R (-1)%R min_one_is_in_base_interval min_one_is_in_base_interval)).
  (* Refining 2 *)
  destruct (not_Qeq_inf _ _ H_efgh1) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh1m.
   (* 2l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + - b + - c + d)%R); apply Rdiv_Rmult_neg_pos_Rle'; auto; try Fourier.fourier;
   stepr (1/3)%R; [|field]; stepl ((a*(-1)*(-1)+b*(-1)+c*(-1)+d)/(e*(-1)*(-1)+f*(-1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh1];
   exact (proj2 (H_xi (-1)%R (-1)%R min_one_is_in_base_interval min_one_is_in_base_interval)).
   (* 2r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + - b + - c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepr (1/3)%R; [|field]; stepl ((a*(-1)*(-1)+b*(-1)+c*(-1)+d)/(e*(-1)*(-1)+f*(-1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh1];
   exact (proj2 (H_xi (-1)%R (-1)%R min_one_is_in_base_interval min_one_is_in_base_interval)).
  (* Refining 3 *)
  destruct (not_Qeq_inf _ _ H_efgh2) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh2m.
   (* 3l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + - b +  c + d)%R); apply Rdiv_Rmult_pos_neg_Rle'; auto; try Fourier.fourier;
   stepl ((-1)/3)%R; [|field]; stepr ((a*(-1)*(1)+b*(-1)+c*(1)+d)/(e*(-1)*(1)+f*(-1)+g*(1)+h))%R; [|field; ring_exact_R H_efgh2];
   exact (proj1 (H_xi (-1)%R (1)%R min_one_is_in_base_interval one_is_in_base_interval)).
   (* 3r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + - b + c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepl ((-1)/3)%R; [|field]; stepr ((a*(-1)*(1)+b*(-1)+c*(1)+d)/(e*(-1)*(1)+f*(-1)+g*(1)+h))%R; [|field; ring_exact_R H_efgh2];
   exact (proj1 (H_xi (-1)%R (1)%R min_one_is_in_base_interval one_is_in_base_interval)).
  (* Refining 4 *)
  destruct (not_Qeq_inf _ _ H_efgh2) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh2m.
   (* 4l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + - b +  c + d)%R); apply Rdiv_Rmult_neg_pos_Rle'; auto; try Fourier.fourier;
   stepr (1/3)%R; [|field]; stepl ((a*(-1)*(1)+b*(-1)+c*(1)+d)/(e*(-1)*(1)+f*(-1)+g*(1)+h))%R; [|field; ring_exact_R H_efgh2];
   exact (proj2 (H_xi (-1)%R (1)%R min_one_is_in_base_interval one_is_in_base_interval)).
   (* 4r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + - b + c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepr (1/3)%R; [|field]; stepl ((a*(-1)*(1)+b*(-1)+c*(1)+d)/(e*(-1)*(1)+f*(-1)+g*(1)+h))%R; [|field; ring_exact_R H_efgh2];
   exact (proj2 (H_xi (-1)%R (1)%R min_one_is_in_base_interval one_is_in_base_interval)).
  (* Refining 5 *)
  destruct (not_Qeq_inf _ _ H_efgh3) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh3m.
   (* 5l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a +  b + -c + d)%R); apply Rdiv_Rmult_pos_neg_Rle'; auto; try Fourier.fourier;
   stepl ((-1)/3)%R; [|field]; stepr ((a*(1)*(-1)+b*(1)+c*(-1)+d)/(e*(1)*(-1)+f*(1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh3];
   exact (proj1 (H_xi (1)%R (-1)%R one_is_in_base_interval min_one_is_in_base_interval)).
   (* 5r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a +  b + -c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepl ((-1)/3)%R; [|field]; stepr ((a*(1)*(-1)+b*(1)+c*(-1)+d)/(e*(1)*(-1)+f*(1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh3];
   exact (proj1 (H_xi (1)%R (-1)%R one_is_in_base_interval min_one_is_in_base_interval)).
  (* Refining 6 *)
  destruct (not_Qeq_inf _ _ H_efgh3) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh3m.
   (* 6l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a + b +  -c + d)%R); apply Rdiv_Rmult_neg_pos_Rle'; auto; try Fourier.fourier;
   stepr (1/3)%R; [|field];  stepl ((a*(1)*(-1)+b*(1)+c*(-1)+d)/(e*(1)*(-1)+f*(1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh3];
   exact (proj2 (H_xi (1)%R (-1)%R one_is_in_base_interval min_one_is_in_base_interval)).
   (* 6r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (-a +  b + -c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepr (1/3)%R; [|field]; stepl ((a*(1)*(-1)+b*(1)+c*(-1)+d)/(e*(1)*(-1)+f*(1)+g*(-1)+h))%R; [|field; ring_exact_R H_efgh3];
   exact (proj2 (H_xi (1)%R (-1)%R one_is_in_base_interval min_one_is_in_base_interval)).
  (* Refining 7 *)
  destruct (not_Qeq_inf _ _ H_efgh4) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh4m.
   (* 7l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a +  b + c + d)%R); apply Rdiv_Rmult_pos_neg_Rle'; auto; try Fourier.fourier;
   stepl ((-1)/3)%R; [|field]; stepr ((a*1*1+b*1+c*1+d)/(e*1*1+f*1+g*1+h))%R; [|field; ring_exact_R H_efgh4];
   exact (proj1 (H_xi (1)%R (1)%R one_is_in_base_interval one_is_in_base_interval)).
   (* 7r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a +  b + c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepl ((-1)/3)%R; [|field]; stepr ((a*1*1+b*1+c*1+d)/(e*1*1+f*1+g*1+h))%R; [|field; ring_exact_R H_efgh4];
   exact (proj1 (H_xi (1)%R (1)%R one_is_in_base_interval one_is_in_base_interval)).
  (* Refining 8 *)
  destruct (not_Qeq_inf _ _ H_efgh4) as [H_|H_]; apply Q_to_R_Qle; realify_Q; auto;
  intros H_efgh1 H_efgh2 H_efgh3 H_efgh4 H_h H_egh4m.
   (* 8l *)
   apply Rmult_le_compat_neg_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a + b +  c + d)%R); apply Rdiv_Rmult_neg_pos_Rle'; auto; try Fourier.fourier;
   stepr (1/3)%R; [|field]; stepl ((a*1*1+b*1+c*1+d)/(e*1*1+f*1+g*1+h))%R; [|field; ring_exact_R H_efgh4];
   exact (proj2 (H_xi (1)%R (1)%R one_is_in_base_interval one_is_in_base_interval)).
   (* 8r *) 
   apply Rmult_le_compat_l; [Fourier.fourier|];
   rewrite (Rmult_comm (a +  b + c + d)%R); apply Rdiv_Rmult_pos_pos_Rle';  auto; try Fourier.fourier;
   stepr (1/3)%R; [|field]; stepl ((a*1*1+b*1+c*1+d)/(e*1*1+f*1+g*1+h))%R; [|field; ring_exact_R H_efgh4];
   exact (proj2 (H_xi (1)%R (1)%R one_is_in_base_interval one_is_in_base_interval)).
Qed.

Lemma Bounded_T_Incl_T_L_folded: forall xi, Bounded_T xi ->
  (forall r1 r2,(-1 <= r1 <= 1)%R -> (-1 <= r2 <= 1)%R -> (-1 <= as_Tensor xi r1 r2 <= 0)%R) -> Incl_T xi LL.
Proof.
 intros xi H_bound; generalize (Bounded_T_denom_nonvanishing_T xi H_bound); apply Incl_T_L_folded.
Qed.

Lemma Bounded_T_Incl_T_R_folded: forall xi, Bounded_T xi ->
  (forall r1 r2,(-1 <= r1 <= 1)%R -> (-1 <= r2 <= 1)%R -> (0<= as_Tensor xi r1 r2 <= 1)%R) -> Incl_T xi RR.
Proof.
 intros xi H_bound; generalize (Bounded_T_denom_nonvanishing_T xi H_bound); apply Incl_T_R_folded.
Qed.

Lemma Bounded_T_Incl_T_M_folded: forall xi, Bounded_T xi ->
     (forall r1 r2,(-1 <= r1 <= 1)%R -> (-1 <= r2 <= 1)%R -> ((-1/3)<= as_Tensor xi r1 r2 <= 1/3)%R) -> Incl_T xi MM.
Proof.
 intros xi H_bound; generalize (Bounded_T_denom_nonvanishing_T xi H_bound); apply Incl_T_M_folded.
Qed.

Close Scope Q_scope.